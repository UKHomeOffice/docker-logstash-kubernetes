filter {
  if "kubernetes" and "audit" in [tags] {
    # Splitting original message to get access to event timestamp.
    mutate {
      split => { 
        "message" => " " 
      }
    }

    # Extract timestamp of the acutal event and overwrite @timestamp
    date {
      match => [ "[message][0]", "ISO8601"]
    }

    # Extract event key-values
    kv {
      field_split => " "
      value_split => "="
      target => "message"
    }

    # Decode endpoint URL
    urldecode {
      field => "[message][uri]"
    }

    # Temporarily slit URI into endpoint / query_string parts 
    mutate {
      split => { 
        "[message][uri]" => "?" 
      }
    }

    # If query_string exists split them into KV pairs
    if [message][uri][1] {
      kv {
        source => "[message][uri][1]"
        target => "[message][query_params]"
        field_split => "&"
        value_split => "="
        add_field => { "[message][endpoint]" => "%{[message][uri][0]}" }
        remove_field => "[message][uri]"
        allow_duplicate_values => false
        add_tag => ["kubernetes_audit_filtered"]
      }
    } else { # No query_string present
      mutate {
        add_field => { "[message][endpoint]" => "%{[message][uri][0]}" }
        remove_field => "[message][uri]"
        add_tag => ["kubernetes_audit_filtered"]
      }        
    }
  }
}

output {
  if "kubernetes_audit_filtered" in [tags] {
    elasticsearch {
      index => "kubernetes-%ELASTICSEARCH_INDEX_SUFFIX%%{+YYYY.MM.dd}"
      document_type => "kubernetes_audit"
      hosts => [ "%ELASTICSEARCH_HOST%" ]
      validate_after_inactivity => 60
      idle_flush_time => %ELASTICSEARCH_IDLE_FLUSH_TIME%
      flush_size => %ELASTICSEARCH_FLUSH_SIZE%
    }
  }
}

